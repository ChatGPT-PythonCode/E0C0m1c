<!DOCTYPE html>
<html lang="en" class="bg-black">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EO Guides</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Retro Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    body { font-family: system-ui, -apple-system, sans-serif; }
    .retro { font-family: 'Press Start 2P', cursive; }
    html { scroll-behavior: smooth; }

    .fade-in { animation: fade .25s ease; }
    @keyframes fade { from {opacity:0} to {opacity:1} }

    .no-scroll { overflow: hidden; }

    /* smoother scrolling on iOS inside modal */
    #readerScroll { -webkit-overflow-scrolling: touch; }

    /* iOS safe area */
    .safe-bottom { padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
    .safe-top { padding-top: calc(1rem + env(safe-area-inset-top)); }

    /* tiny shimmer placeholder */
    .shimmer {
      background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.12), rgba(255,255,255,.06));
      background-size: 200% 100%;
      animation: shimmer 1.2s infinite linear;
    }
    @keyframes shimmer { 0%{background-position:0% 0} 100%{background-position:-200% 0} }
  </style>
</head>

<body class="bg-black text-white">

<!-- HEADER -->
<header class="sticky top-0 z-40 bg-black/80 backdrop-blur border-b border-white/10">
  <div class="max-w-6xl mx-auto px-4 py-4 flex justify-between items-center">
    <h1 class="retro text-xs sm:text-sm tracking-widest">EO GUIDES</h1>
    <button onclick="openDisclaimer()" class="text-xs opacity-70 hover:opacity-100">
      Disclaimer
    </button>
  </div>
</header>

<!-- ARCHIVE GRID -->
<main class="max-w-6xl mx-auto px-4 py-8">

  <div id="status" class="text-center text-sm opacity-70 py-10">
    Loading comics…
  </div>

  <div id="grid" class="hidden grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"></div>

</main>

<!-- READER MODAL -->
<div id="reader" class="fixed inset-0 bg-black/95 hidden z-50 flex flex-col">

  <div class="flex justify-between items-center px-4 py-3 border-b border-white/10 safe-top">
    <button onclick="closeReader()" class="retro text-xs">Close</button>
    <div id="pageCounter" class="retro text-[10px] sm:text-xs text-right"></div>
  </div>

  <!-- Scroll container -->
  <div id="readerScroll" class="flex-1 overflow-auto p-3 sm:p-4">
    <div id="readerPlaceholder" class="max-w-4xl mx-auto w-full aspect-[3/4] rounded-xl shimmer"></div>
    <img id="readerImage"
         class="hidden w-full max-w-4xl mx-auto h-auto fade-in select-none"
         alt="Comic page"
         decoding="async"
         fetchpriority="high" />
  </div>

  <div class="flex justify-between gap-3 px-4 py-3 border-t border-white/10 safe-bottom">
    <button id="prevBtn" onclick="prevPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Prev
    </button>
    <button id="nextBtn" onclick="nextPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Next
    </button>
  </div>

</div>

<!-- DISCLAIMER MODAL -->
<div id="disclaimer"
     class="fixed inset-0 bg-black/90 hidden z-50 flex items-center justify-center p-6">

  <div class="bg-neutral-900 rounded-2xl p-6 max-w-xl w-full border border-white/10">
    <h2 class="retro text-xs mb-4">Viewer Discretion Advised</h2>

    <p class="text-sm leading-relaxed opacity-80">
      This website contains crude humor, retro nonsense, and satire.
      All characters and events are fictional. Even the ones that seem real.
    </p>

    <div class="mt-6 text-right">
      <button onclick="acceptDisclaimer()"
              class="retro text-xs bg-white text-black px-4 py-2 rounded-lg">
        I Understand
      </button>
    </div>
  </div>
</div>

<script>
  // === CONFIG ===
  const OWNER = "ChatGPT-PythonCode";
  const REPO  = "E0C0m1c";
  const BRANCH = "main";
  const COMICS_PATH = "img/comics";

  // GitHub API listing (so we ONLY show images that exist)
  const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${COMICS_PATH}?ref=${BRANCH}`;

  // Faster CDN for GitHub repos (serves from edge cache)
  // Example: https://cdn.jsdelivr.net/gh/OWNER/REPO@BRANCH/img/comics/001.jpg
  const CDN_BASE_URL = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}@${BRANCH}/${COMICS_PATH}/`;

  // Fallback base URL (only used if API listing fails)
  const RAW_BASE_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/refs/heads/${BRANCH}/${COMICS_PATH}/`;

  // Cache the file list so the page feels instant after first visit
  const CACHE_KEY = "eo_guides_comics_v2";
  const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24h

  let comics = [];           // [{name, url}]
  let currentIndex = 0;

  const statusEl = document.getElementById("status");
  const gridEl = document.getElementById("grid");

  function byNaturalName(a, b) {
    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" });
  }

  function setStatus(msg) {
    statusEl.classList.remove("hidden");
    statusEl.textContent = msg;
  }

  function showGrid() {
    statusEl.classList.add("hidden");
    gridEl.classList.remove("hidden");
  }

  function hideGrid() {
    gridEl.classList.add("hidden");
  }

  function loadFromCache() {
    try {
      const raw = localStorage.getItem(CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== "number") return null;
      if (Date.now() - parsed.ts > CACHE_TTL_MS) return null;
      return parsed.items;
    } catch {
      return null;
    }
  }

  function saveToCache(items) {
    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
    } catch {}
  }

  function urlsFromName(name) {
    // Use CDN for speed, with automatic fallback to raw if CDN has issues.
    return {
      cdn: `${CDN_BASE_URL}${encodeURIComponent(name)}`,
      raw: `${RAW_BASE_URL}${encodeURIComponent(name)}`
    };
  }

  async function loadComics() {
    hideGrid();

    // 1) Instant render from cache (if available)
    const cached = loadFromCache();
    if (cached && cached.length) {
      comics = cached.sort(byNaturalName);
      renderGrid();
      showGrid();
      setStatus("Refreshing…"); // mild hint while we refresh in background
    } else {
      setStatus("Loading comics…");
    }

    // 2) Try fresh file list from GitHub API
    try {
      const res = await fetch(API_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`GitHub API returned ${res.status}`);
      const data = await res.json();

      const fresh = data
        .filter(x => x.type === "file" && /\.(jpe?g|png|webp|gif)$/i.test(x.name))
        .map(x => ({ name: x.name, url: urlsFromName(x.name).cdn }))
        .sort(byNaturalName);

      if (!fresh.length) {
        setStatus("No images found in img/comics.");
        return;
      }

      // Only re-render if list differs (keeps things smooth)
      const changed = JSON.stringify(fresh.map(x => x.name)) !== JSON.stringify(comics.map(x => x.name));
      comics = fresh;
      saveToCache(comics);

      if (!cached || changed) {
        renderGrid();
        showGrid();
      } else {
        statusEl.classList.add("hidden");
      }

      return;

    } catch (err) {
      console.warn("GitHub API listing failed; falling back.", err);
      if (comics.length) {
        // We already rendered from cache; keep it and stop here.
        statusEl.classList.add("hidden");
        return;
      }
    }

    // 3) Fallback: probe sequential files (still avoids showing missing ones)
    setStatus("Scanning images…");

    const max = 500;
    const found = [];
    const concurrency = 12;

    async function exists(url) {
      try {
        // jsDelivr supports HEAD; raw might not always; this keeps it robust
        let r = await fetch(url, { method: "HEAD" });
        if (r.ok) return true;
        r = await fetch(url, { method: "GET" });
        return r.ok;
      } catch {
        return false;
      }
    }

    const tasks = [];
    for (let i = 1; i <= max; i++) {
      const num = String(i).padStart(3, "0");
      const name = `${num}.jpg`;
      tasks.push({ name, url: urlsFromName(name).cdn });
    }

    for (let i = 0; i < tasks.length; i += concurrency) {
      const batch = tasks.slice(i, i + concurrency);
      const results = await Promise.all(batch.map(t => exists(t.url)));
      results.forEach((ok, idx) => { if (ok) found.push(batch[idx]); });

      setStatus(`Scanning images… ${Math.min(i + concurrency, max)} / ${max}`);
    }

    comics = found.sort(byNaturalName);

    if (!comics.length) {
      setStatus("Couldn't find any images to load.");
      return;
    }

    saveToCache(comics);
    renderGrid();
    showGrid();
  }

  function renderGrid() {
    gridEl.innerHTML = "";

    comics.forEach((comic, idx) => {
      const card = document.createElement("button");
      card.type = "button";
      card.className =
        "relative cursor-pointer bg-neutral-900 rounded-xl overflow-hidden hover:scale-105 transition focus:outline-none focus:ring-2 focus:ring-white/30";

      card.addEventListener("click", () => openReader(idx));

      // lightweight placeholder while image loads
      const ph = document.createElement("div");
      ph.className = "absolute inset-0 shimmer";
      card.appendChild(ph);

      const img = document.createElement("img");
      img.src = comic.url;
      img.loading = "lazy";
      img.decoding = "async";
      img.fetchPriority = "low";
      img.alt = comic.name;
      img.className = "relative w-full aspect-[3/4] object-cover";

      // If CDN fails for any reason, fall back to raw URL
      img.onerror = () => {
        const fallback = urlsFromName(comic.name).raw;
        if (img.src !== fallback) img.src = fallback;
        else card.remove(); // if even raw fails, drop it
      };

      img.onload = () => ph.remove();

      card.appendChild(img);
      gridEl.appendChild(card);
    });
  }

  function openReader(idx) {
    if (!comics.length) return;
    currentIndex = Math.max(0, Math.min(idx, comics.length - 1));
    updateReader();

    document.getElementById("reader").classList.remove("hidden");
    document.body.classList.add("no-scroll");
    document.getElementById("readerScroll").scrollTop = 0;
  }

  function closeReader() {
    document.getElementById("reader").classList.add("hidden");
    document.body.classList.remove("no-scroll");
  }

  // Preload next/prev so navigation feels instant
  const preloadCache = new Map(); // url -> Image
  function preload(url) {
    if (!url || preloadCache.has(url)) return;
    const im = new Image();
    im.decoding = "async";
    im.src = url;
    preloadCache.set(url, im);

    // simple cap to avoid unbounded memory
    if (preloadCache.size > 12) {
      const firstKey = preloadCache.keys().next().value;
      preloadCache.delete(firstKey);
    }
  }

  function preloadAround() {
    if (!comics.length) return;
    const prev = comics[currentIndex - 1]?.url;
    const next = comics[currentIndex + 1]?.url;
    preload(prev);
    preload(next);
  }

  function updateReader() {
    const comic = comics[currentIndex];

    const img = document.getElementById("readerImage");
    const ph  = document.getElementById("readerPlaceholder");

    // show placeholder while new page loads
    img.classList.add("hidden");
    ph.classList.remove("hidden");

    // Set source (CDN). If it fails, swap to raw.
    img.onerror = () => {
      const fallback = urlsFromName(comic.name).raw;
      if (img.src !== fallback) img.src = fallback;
    };

    img.onload = () => {
      ph.classList.add("hidden");
      img.classList.remove("hidden");
    };

    img.src = comic.url;

    document.getElementById("pageCounter").innerText =
      `${currentIndex + 1} / ${comics.length} • ${comic.name}`;

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const atStart = currentIndex === 0;
    const atEnd = currentIndex === comics.length - 1;

    prevBtn.classList.toggle("opacity-30", atStart);
    prevBtn.classList.toggle("pointer-events-none", atStart);

    nextBtn.classList.toggle("opacity-30", atEnd);
    nextBtn.classList.toggle("pointer-events-none", atEnd);

    preloadAround();
  }

  function nextPage() {
    if (currentIndex < comics.length - 1) {
      currentIndex++;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  function prevPage() {
    if (currentIndex > 0) {
      currentIndex--;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  // Keyboard controls
  document.addEventListener("keydown", e => {
    const readerOpen = !document.getElementById("reader").classList.contains("hidden");
    if (!readerOpen) return;

    if (e.key === "ArrowRight") nextPage();
    if (e.key === "ArrowLeft") prevPage();
    if (e.key === "Escape") closeReader();
  });

  // Swipe support (mobile)
  let startX = 0;
  const readerImage = document.getElementById("readerImage");

  readerImage.addEventListener("touchstart", e => {
    startX = e.touches[0].clientX;
  }, { passive: true });

  readerImage.addEventListener("touchend", e => {
    const diff = e.changedTouches[0].clientX - startX;
    if (diff > 60) prevPage();
    if (diff < -60) nextPage();
  }, { passive: true });

  // DISCLAIMER
  function openDisclaimer() {
    document.getElementById("disclaimer").classList.remove("hidden");
    document.body.classList.add("no-scroll");
  }

  function acceptDisclaimer() {
    localStorage.setItem("discAccepted", "true");
    document.getElementById("disclaimer").classList.add("hidden");
    document.body.classList.remove("no-scroll");
  }

  if (!localStorage.getItem("discAccepted")) {
    openDisclaimer();
  }

  // Kick off
  loadComics();
</script>

</body>
</html>
