<!DOCTYPE html>
<html lang="en" class="bg-black">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EOWeb Comics</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Retro Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    body { font-family: system-ui, -apple-system, sans-serif; }
    .retro { font-family: 'Press Start 2P', cursive; }
    html { scroll-behavior: smooth; }

    .fade-in { animation: fade .25s ease; }
    @keyframes fade { from {opacity:0} to {opacity:1} }

    .no-scroll { overflow: hidden; }
    #readerScroll { -webkit-overflow-scrolling: touch; }

    .safe-bottom { padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
    .safe-top { padding-top: calc(1rem + env(safe-area-inset-top)); }

    .shimmer {
      background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.12), rgba(255,255,255,.06));
      background-size: 200% 100%;
      animation: shimmer 1.2s infinite linear;
    }
    @keyframes shimmer { 0%{background-position:0% 0} 100%{background-position:-200% 0} }
  </style>
</head>

<body class="bg-black text-white">

<!-- HEADER -->
<header class="sticky top-0 z-40 bg-black/80 backdrop-blur border-b border-white/10">
  <div class="max-w-6xl mx-auto px-4 py-4 flex justify-between items-center">
    <h1 class="retro text-xs sm:text-sm tracking-widest">EO GUIDES</h1>
    <button onclick="openDisclaimer()" class="text-xs opacity-70 hover:opacity-100">
      Disclaimer
    </button>
  </div>
</header>

<!-- ARCHIVE GRID -->
<main class="max-w-6xl mx-auto px-4 py-8">

  <div id="status" class="text-center text-sm opacity-70 py-10">
    Loading comics…
  </div>

  <div id="grid" class="hidden grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"></div>

</main>

<!-- READER MODAL -->
<div id="reader" class="fixed inset-0 bg-black/95 hidden z-50 flex flex-col">

  <div class="flex justify-between items-center px-4 py-3 border-b border-white/10 safe-top gap-3">
    <button onclick="closeReader()" class="retro text-xs shrink-0">Close</button>

    <div class="flex-1 min-w-0 text-right">
      <div id="pageCounter" class="retro text-[10px] sm:text-xs truncate"></div>
      <div class="mt-2 flex justify-end gap-2">
        <button id="copyLinkBtn"
                onclick="copyShareLink()"
                class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-3 py-2 rounded-xl">
          Copy Link
        </button>
        <button id="shareBtn"
                onclick="nativeShare()"
                class="retro text-[10px] sm:text-xs bg-white text-black px-3 py-2 rounded-xl hidden">
          Share
        </button>
      </div>
    </div>
  </div>

  <!-- Scroll container -->
  <div id="readerScroll" class="flex-1 overflow-auto p-3 sm:p-4">
    <div id="readerPlaceholder" class="max-w-4xl mx-auto w-full aspect-[3/4] rounded-xl shimmer"></div>
    <img id="readerImage"
         class="hidden w-full max-w-4xl mx-auto h-auto fade-in select-none"
         alt="Comic page"
         decoding="async"
         fetchpriority="high" />
  </div>

  <div class="flex justify-between gap-3 px-4 py-3 border-t border-white/10 safe-bottom">
    <button id="prevBtn" onclick="prevPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Prev
    </button>
    <button id="nextBtn" onclick="nextPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Next
    </button>
  </div>

</div>

<!-- DISCLAIMER MODAL -->
<div id="disclaimer"
     class="fixed inset-0 bg-black/90 hidden z-50 flex items-center justify-center p-6">

  <div class="bg-neutral-900 rounded-2xl p-6 max-w-xl w-full border border-white/10">
    <h2 class="retro text-xs mb-4">Viewer Discretion Advised</h2>

    <p class="text-sm leading-relaxed opacity-80">
      This website contains crude humor, retro nonsense, and satire.
      All characters and events are fictional. Even the ones that seem real.
    </p>

    <div class="mt-6 text-right">
      <button onclick="acceptDisclaimer()"
              class="retro text-xs bg-white text-black px-4 py-2 rounded-lg">
        I Understand
      </button>
    </div>
  </div>
</div>

<script>
  // === CONFIG ===
  const OWNER = "ChatGPT-PythonCode";
  const REPO  = "E0C0m1c";
  const BRANCH = "main";
  const COMICS_PATH = "img/comics";

  // GitHub API listing (so we ONLY show images that exist)
  const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${COMICS_PATH}?ref=${BRANCH}`;

  // Faster CDN for GitHub repos (serves from edge cache)
  const CDN_BASE_URL = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}@${BRANCH}/${COMICS_PATH}/`;

  // Fallback base URL (only used if API listing fails)
  const RAW_BASE_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/refs/heads/${BRANCH}/${COMICS_PATH}/`;

  // Cache the file list so the page feels instant after first visit
  const CACHE_KEY = "eo_guides_comics_v3";
  const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24h

  // Shareable URL route:
  //   /imgurl/<filename>
  // Example:
  //   https://yoursite.com/imgurl/001.jpg
  //
  // NOTE: For this to work on direct load, your host must rewrite /imgurl/* to index.html (SPA routing).
  // If you can't do rewrites, you can still share using the hash fallback:
  //   https://yoursite.com/#/imgurl/001.jpg
  const SHARE_PREFIX = "imgurl";

  let comics = [];           // [{name, url}]
  let currentIndex = 0;

  const statusEl = document.getElementById("status");
  const gridEl = document.getElementById("grid");

  function byNaturalName(a, b) {
    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" });
  }

  function setStatus(msg) {
    statusEl.classList.remove("hidden");
    statusEl.textContent = msg;
  }

  function showGrid() {
    statusEl.classList.add("hidden");
    gridEl.classList.remove("hidden");
  }

  function hideGrid() {
    gridEl.classList.add("hidden");
  }

  function loadFromCache() {
    try {
      const raw = localStorage.getItem(CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== "number") return null;
      if (Date.now() - parsed.ts > CACHE_TTL_MS) return null;
      return parsed.items;
    } catch {
      return null;
    }
  }

  function saveToCache(items) {
    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
    } catch {}
  }

  function urlsFromName(name) {
    return {
      cdn: `${CDN_BASE_URL}${encodeURIComponent(name)}`,
      raw: `${RAW_BASE_URL}${encodeURIComponent(name)}`
    };
  }

  // ---- Shareable URL helpers ----

  function baseDir() {
    // Returns the directory path of the current URL (keeps GitHub Pages repo subdirectory).
    // e.g. /repo/ or / if hosted at root.
    const path = location.pathname;
    // If we are already in /.../imgurl/... treat base as everything before /imgurl/
    const marker = `/${SHARE_PREFIX}/`;
    if (path.includes(marker)) return path.split(marker)[0] + "/";
    // If ends with .html, strip file. Otherwise strip last segment if it's not a directory.
    if (path.endsWith("/")) return path;
    const lastSlash = path.lastIndexOf("/");
    return path.slice(0, lastSlash + 1);
  }

  function makeSharePath(filename) {
    // /<base>/imgurl/<filename>
    return baseDir() + SHARE_PREFIX + "/" + encodeURIComponent(filename);
  }

  function makeShareUrl(filename) {
    return location.origin + makeSharePath(filename);
  }

  function makeHashShareUrl(filename) {
    return location.origin + baseDir() + "#/" + SHARE_PREFIX + "/" + encodeURIComponent(filename);
  }

  function parseFilenameFromUrl() {
    // Try:
    // 1) /.../imgurl/<filename>
    // 2) ?img=<filename>
    // 3) #/imgurl/<filename>
    const path = location.pathname;
    const marker = `/${SHARE_PREFIX}/`;
    if (path.includes(marker)) {
      const part = path.split(marker)[1] || "";
      if (part) return decodeURIComponent(part.split("/")[0]);
    }

    const u = new URL(location.href);
    const img = u.searchParams.get("img");
    if (img) return img;

    const h = location.hash || "";
    const hm = h.match(new RegExp(`#\/${SHARE_PREFIX}\/([^?#]+)`));
    if (hm && hm[1]) return decodeURIComponent(hm[1]);

    return null;
  }

  function setUrlForCurrent(replace=false) {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;

    // Prefer clean /imgurl/<file> path.
    // If your host doesn't support rewrites, you can swap this to always use hash:
    //   location.hash = `#/${SHARE_PREFIX}/${encodeURIComponent(filename)}`
    const newPath = makeSharePath(filename);

    try {
      if (replace) history.replaceState({ img: filename }, "", newPath);
      else history.pushState({ img: filename }, "", newPath);
    } catch {
      // Fallback to hash-based routing (always works on static hosting)
      location.hash = `#/${SHARE_PREFIX}/${encodeURIComponent(filename)}`;
    }

    // Update title a bit
    document.title = `EO Guides • ${filename}`;
  }

  function setUrlToHome(replace=false) {
    const home = baseDir(); // directory (e.g. /repo/)
    try {
      if (replace) history.replaceState({}, "", home);
      else history.pushState({}, "", home);
    } catch {
      location.hash = "";
    }
    document.title = "EO Guides";
  }

  function indexForFilename(filename) {
    if (!filename) return -1;
    return comics.findIndex(c => c.name.toLowerCase() === filename.toLowerCase());
  }

  // ---- Load comics list + render ----

  async function loadComics() {
    hideGrid();

    // 1) Instant render from cache (if available)
    const cached = loadFromCache();
    if (cached && cached.length) {
      comics = cached.sort(byNaturalName);
      renderGrid();
      showGrid();
      setStatus("Refreshing…");
    } else {
      setStatus("Loading comics…");
    }

    // 2) Try fresh file list from GitHub API
    try {
      const res = await fetch(API_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`GitHub API returned ${res.status}`);
      const data = await res.json();

      const fresh = data
        .filter(x => x.type === "file" && /\.(jpe?g|png|webp|gif)$/i.test(x.name))
        .map(x => ({ name: x.name, url: urlsFromName(x.name).cdn }))
        .sort(byNaturalName);

      if (!fresh.length) {
        setStatus("No images found in img/comics.");
        return;
      }

      const changed = JSON.stringify(fresh.map(x => x.name)) !== JSON.stringify(comics.map(x => x.name));
      comics = fresh;
      saveToCache(comics);

      if (!cached || changed) {
        renderGrid();
        showGrid();
      } else {
        statusEl.classList.add("hidden");
      }

      maybeOpenFromUrl();
      return;

    } catch (err) {
      console.warn("GitHub API listing failed; falling back.", err);
      if (comics.length) {
        statusEl.classList.add("hidden");
        maybeOpenFromUrl();
        return;
      }
    }

    // 3) Fallback: probe sequential files (still avoids showing missing ones)
    setStatus("Scanning images…");

    const max = 500;
    const found = [];
    const concurrency = 12;

    async function exists(url) {
      try {
        let r = await fetch(url, { method: "HEAD" });
        if (r.ok) return true;
        r = await fetch(url, { method: "GET" });
        return r.ok;
      } catch {
        return false;
      }
    }

    const tasks = [];
    for (let i = 1; i <= max; i++) {
      const num = String(i).padStart(3, "0");
      const name = `${num}.jpg`;
      tasks.push({ name, url: urlsFromName(name).cdn });
    }

    for (let i = 0; i < tasks.length; i += concurrency) {
      const batch = tasks.slice(i, i + concurrency);
      const results = await Promise.all(batch.map(t => exists(t.url)));
      results.forEach((ok, idx) => { if (ok) found.push(batch[idx]); });
      setStatus(`Scanning images… ${Math.min(i + concurrency, max)} / ${max}`);
    }

    comics = found.sort(byNaturalName);

    if (!comics.length) {
      setStatus("Couldn't find any images to load.");
      return;
    }

    saveToCache(comics);
    renderGrid();
    showGrid();
    maybeOpenFromUrl();
  }

  function renderGrid() {
    gridEl.innerHTML = "";

    comics.forEach((comic, idx) => {
      // Use <a> so users can right-click / long-press and copy the per-image URL.
      const link = document.createElement("a");
      link.href = makeSharePath(comic.name);
      link.className =
        "relative block cursor-pointer bg-neutral-900 rounded-xl overflow-hidden hover:scale-105 transition focus:outline-none focus:ring-2 focus:ring-white/30";

      // Clicking uses the modal (SPA behavior)
      link.addEventListener("click", (e) => {
        e.preventDefault();
        openReader(idx, false);
      });

      const ph = document.createElement("div");
      ph.className = "absolute inset-0 shimmer";
      link.appendChild(ph);

      const img = document.createElement("img");
      img.src = comic.url;
      img.loading = "lazy";
      img.decoding = "async";
      img.fetchPriority = "low";
      img.alt = comic.name;
      img.className = "relative w-full aspect-[3/4] object-cover";

      img.onerror = () => {
        const fallback = urlsFromName(comic.name).raw;
        if (img.src !== fallback) img.src = fallback;
        else link.remove();
      };

      img.onload = () => ph.remove();

      link.appendChild(img);
      gridEl.appendChild(link);
    });
  }

  // ---- Reader modal ----

  function openReader(idx, push=true) {
    if (!comics.length) return;
    currentIndex = Math.max(0, Math.min(idx, comics.length - 1));
    updateReader();
    document.getElementById("reader").classList.remove("hidden");
    document.body.classList.add("no-scroll");
    document.getElementById("readerScroll").scrollTop = 0;

    // show native share button on supported devices
    document.getElementById("shareBtn").classList.toggle("hidden", !("share" in navigator));

    if (push) setUrlForCurrent(false);
    else setUrlForCurrent(true);
  }

  function closeReader() {
    document.getElementById("reader").classList.add("hidden");
    document.body.classList.remove("no-scroll");
    setUrlToHome(false);
  }

  // Preload next/prev
  const preloadCache = new Map();
  function preload(url) {
    if (!url || preloadCache.has(url)) return;
    const im = new Image();
    im.decoding = "async";
    im.src = url;
    preloadCache.set(url, im);
    if (preloadCache.size > 12) {
      const firstKey = preloadCache.keys().next().value;
      preloadCache.delete(firstKey);
    }
  }

  function preloadAround() {
    const prev = comics[currentIndex - 1]?.url;
    const next = comics[currentIndex + 1]?.url;
    preload(prev); preload(next);
  }

  function updateReader() {
    const comic = comics[currentIndex];
    const img = document.getElementById("readerImage");
    const ph  = document.getElementById("readerPlaceholder");

    img.classList.add("hidden");
    ph.classList.remove("hidden");

    img.onerror = () => {
      const fallback = urlsFromName(comic.name).raw;
      if (img.src !== fallback) img.src = fallback;
    };

    img.onload = () => {
      ph.classList.add("hidden");
      img.classList.remove("hidden");
    };

    img.src = comic.url;

    document.getElementById("pageCounter").innerText =
      `${currentIndex + 1} / ${comics.length} • ${comic.name}`;

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const atStart = currentIndex === 0;
    const atEnd = currentIndex === comics.length - 1;

    prevBtn.classList.toggle("opacity-30", atStart);
    prevBtn.classList.toggle("pointer-events-none", atStart);

    nextBtn.classList.toggle("opacity-30", atEnd);
    nextBtn.classList.toggle("pointer-events-none", atEnd);

    preloadAround();
    // keep URL in sync (replace so back button works nicely)
    setUrlForCurrent(true);
  }

  function nextPage() {
    if (currentIndex < comics.length - 1) {
      currentIndex++;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  function prevPage() {
    if (currentIndex > 0) {
      currentIndex--;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  // ---- Sharing ----

  function currentShareUrl() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return location.href;
    // Prefer clean path, but provide hash fallback if needed.
    // (You can swap to always use hash if your host doesn't rewrite /imgurl/*.)
    return makeShareUrl(filename);
  }

  async function copyShareLink() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;

    // Try clean path; if copying fails due to routing concerns, use hash fallback.
    const url = currentShareUrl();
    const fallback = makeHashShareUrl(filename);

    try {
      await navigator.clipboard.writeText(url);
      flashCopy("Copied!");
    } catch {
      try {
        // Older browsers
        const ta = document.createElement("textarea");
        ta.value = url;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        flashCopy("Copied!");
      } catch {
        // Last resort
        prompt("Copy this link:", fallback);
      }
    }
  }

  function flashCopy(text) {
    const btn = document.getElementById("copyLinkBtn");
    const old = btn.textContent;
    btn.textContent = text;
    setTimeout(() => btn.textContent = old, 900);
  }

  async function nativeShare() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;
    const url = currentShareUrl();

    try {
      await navigator.share({ title: `EO Guides • ${filename}`, url });
    } catch {}
  }

  // ---- Deep link open ----
  function maybeOpenFromUrl() {
    const filename = parseFilenameFromUrl();
    if (!filename) return;

    const idx = indexForFilename(filename);
    if (idx >= 0) {
      openReader(idx, false);
    } else {
      // If filename isn't found, go back home
      setUrlToHome(true);
    }
  }

  // Back/forward should update modal state
  window.addEventListener("popstate", () => {
    const filename = parseFilenameFromUrl();
    if (!filename) {
      // Close modal if open
      if (!document.getElementById("reader").classList.contains("hidden")) {
        document.getElementById("reader").classList.add("hidden");
        document.body.classList.remove("no-scroll");
        document.title = "EO Guides";
      }
      return;
    }

    const idx = indexForFilename(filename);
    if (idx >= 0) {
      // Open (or update) reader without adding history entry
      document.getElementById("reader").classList.remove("hidden");
      document.body.classList.add("no-scroll");
      currentIndex = idx;
      updateReader();
    }
  });

  // Keyboard controls
  document.addEventListener("keydown", e => {
    const readerOpen = !document.getElementById("reader").classList.contains("hidden");
    if (!readerOpen) return;

    if (e.key === "ArrowRight") nextPage();
    if (e.key === "ArrowLeft") prevPage();
    if (e.key === "Escape") closeReader();
  });

  // Swipe support
  let startX = 0;
  const readerImage = document.getElementById("readerImage");
  readerImage.addEventListener("touchstart", e => { startX = e.touches[0].clientX; }, { passive: true });
  readerImage.addEventListener("touchend", e => {
    const diff = e.changedTouches[0].clientX - startX;
    if (diff > 60) prevPage();
    if (diff < -60) nextPage();
  }, { passive: true });

  // DISCLAIMER
  function openDisclaimer() {
    document.getElementById("disclaimer").classList.remove("hidden");
    document.body.classList.add("no-scroll");
  }

  function acceptDisclaimer() {
    localStorage.setItem("discAccepted", "true");
    document.getElementById("disclaimer").classList.add("hidden");
    document.body.classList.remove("no-scroll");
  }

  if (!localStorage.getItem("discAccepted")) {
    openDisclaimer();
  }

  // Kick off
  loadComics();
</script>

</body>
</html>
