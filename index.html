<!DOCTYPE html>
<html lang="en" class="bg-black">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EOComics - EOGuides.com</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Retro Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    body { font-family: system-ui, -apple-system, sans-serif; }
    .retro { font-family: 'Press Start 2P', cursive; }
    html { scroll-behavior: smooth; }

    .fade-in { animation: fade .25s ease; }
    @keyframes fade { from {opacity:0} to {opacity:1} }

    .no-scroll { overflow: hidden; }
    #readerScroll { -webkit-overflow-scrolling: touch; }

    .safe-bottom { padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
    .safe-top { padding-top: calc(1rem + env(safe-area-inset-top)); }

    .shimmer {
      background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.12), rgba(255,255,255,.06));
      background-size: 200% 100%;
      animation: shimmer 1.2s infinite linear;
    }
    @keyframes shimmer { 0%{background-position:0% 0} 100%{background-position:-200% 0} }
  </style>
</head>

<body class="bg-black text-white">

<!-- HEADER -->
<header class="sticky top-0 z-40 bg-black/80 backdrop-blur border-b border-white/10">
  <div class="max-w-6xl mx-auto px-4 py-4 flex justify-between items-center">
    <h1 class="retro text-xs sm:text-sm tracking-widest">EO Webcomics - EoGuides.com</h1>
    <div class="flex items-center gap-3">
      <a href="mailto:info@endless-online.com"
         class="text-xs opacity-70 hover:opacity-100"
         aria-label="Contact us by email">
        Contact
      </a>
      <button onclick="openDisclaimer()" class="text-xs opacity-70 hover:opacity-100">
        Disclaimer
      </button>
    </div>
  </div>
</header>

<!-- ARCHIVE GRID -->
<main class="max-w-6xl mx-auto px-4 py-8">

  <!-- Tabs -->
  <div class="flex items-center justify-between gap-3 mb-4">
    <div class="inline-flex rounded-2xl bg-white/5 border border-white/10 p-1">
      <button id="tabAll"
              onclick="setTab('all')"
              class="retro text-[10px] sm:text-xs px-4 py-2 rounded-xl transition">
        All
      </button>
      <button id="tabNewest"
              onclick="setTab('newest')"
              class="retro text-[10px] sm:text-xs px-4 py-2 rounded-xl transition">
        Newest
      </button>
    </div>

    <div id="tabHint" class="text-xs opacity-70 hidden sm:block"></div>
  </div>

  <div id="status" class="text-center text-sm opacity-70 py-10">
    Loading comics…
  </div>

  <div id="grid" class="hidden grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"></div>

  <!-- LINKS -->
  <section class="mt-10 border-t border-white/10 pt-6">
    <h2 class="retro text-[10px] sm:text-xs opacity-80 mb-4">Links</h2>

    <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
      <a href="https://endless-online.com/"
         target="_blank" rel="noopener noreferrer"
         class="block bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-4 py-4">
        <div class="retro text-[10px] sm:text-xs">Official EO</div>
        <div class="text-xs opacity-70 mt-1 break-all">endless-online.com</div>
      </a>

      <a href="https://www.eo-guides.com/"
         target="_blank" rel="noopener noreferrer"
         class="block bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-4 py-4">
        <div class="retro text-[10px] sm:text-xs">Real EO-Guides</div>
        <div class="text-xs opacity-70 mt-1 break-all">www.eo-guides.com</div>
      </a>

      <a href="https://discord.gg/Q8EqzCaX"
         target="_blank" rel="noopener noreferrer"
         class="block bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-4 py-4">
        <div class="retro text-[10px] sm:text-xs">C300</div>
        <div class="text-xs opacity-70 mt-1 break-all">discord.gg/Q8EqzCaX</div>
      </a>

      <a href="https://aeven.xyz/"
         target="_blank" rel="noopener noreferrer"
         class="block bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-4 py-4">
        <div class="retro text-[10px] sm:text-xs">New Aeven Game</div>
        <div class="text-xs opacity-70 mt-1 break-all">aeven.xyz</div>
      </a>
    </div>
  </section>

</main>

<!-- READER MODAL -->
<div id="reader" class="fixed inset-0 bg-black/95 hidden z-50 flex flex-col">

  <div class="flex justify-between items-center px-4 py-3 border-b border-white/10 safe-top gap-3">
    <button onclick="closeReader()" class="retro text-xs shrink-0">Close</button>

    <div class="flex-1 min-w-0 text-right">
      <div id="pageCounter" class="retro text-[10px] sm:text-xs truncate"></div>
      <div class="mt-2 flex justify-end gap-2">
        <button id="copyLinkBtn"
                onclick="copyShareLink()"
                class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-3 py-2 rounded-xl">
          Copy Link
        </button>
        <button id="shareBtn"
                onclick="nativeShare()"
                class="retro text-[10px] sm:text-xs bg-white text-black px-3 py-2 rounded-xl hidden">
          Share
        </button>
      </div>
    </div>
  </div>

  <!-- Scroll container -->
  <div id="readerScroll" class="flex-1 overflow-auto p-3 sm:p-4">
    <div id="readerPlaceholder" class="max-w-4xl mx-auto w-full aspect-[3/4] rounded-xl shimmer"></div>
    <img id="readerImage"
         class="hidden w-full max-w-4xl mx-auto h-auto fade-in select-none"
         alt="Comic page"
         decoding="async"
         fetchpriority="high" />
  </div>

  <div class="flex justify-between gap-3 px-4 py-3 border-t border-white/10 safe-bottom">
    <button id="prevBtn" onclick="prevPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Prev
    </button>
    <button id="nextBtn" onclick="nextPage()"
            class="retro text-[10px] sm:text-xs bg-white/10 hover:bg-white/15 px-4 py-3 rounded-xl w-1/2">
      Next
    </button>
  </div>

</div>

<!-- DISCLAIMER MODAL -->
<div id="disclaimer"
     class="fixed inset-0 bg-black/90 hidden z-50 flex items-center justify-center p-6">

  <div class="bg-neutral-900 rounded-2xl p-6 max-w-xl w-full border border-white/10">
    <h2 class="retro text-xs mb-4">Viewer Discretion Advised</h2>

    <p class="text-sm leading-relaxed opacity-80">
      This website contains crude humor, retro nonsense, and satire.
      All characters and events are fictional. Even the ones that seem real.
    </p>

    <div class="mt-6 text-right">
      <button onclick="acceptDisclaimer()"
              class="retro text-xs bg-white text-black px-4 py-2 rounded-lg">
        I Understand
      </button>
    </div>
  </div>
</div>

<script>
  // === CONFIG ===
  const OWNER = "ChatGPT-PythonCode";
  const REPO  = "E0C0m1c";
  const BRANCH = "main";
  const COMICS_PATH = "img/comics";

  // GitHub API listing (so we ONLY show images that exist)
  const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${COMICS_PATH}?ref=${BRANCH}`;

  // Faster CDN for GitHub repos (serves from edge cache)
  const CDN_BASE_URL = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}@${BRANCH}/${COMICS_PATH}/`;

  // Fallback base URL (only used if API listing fails)
  const RAW_BASE_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/refs/heads/${BRANCH}/${COMICS_PATH}/`;

  // Cache the file list so the page feels instant after first visit
  const CACHE_KEY = "eo_guides_comics_v4";
  const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24h

  // Shareable URL route:
  //   /imgurl/<filename>
  const SHARE_PREFIX = "/img/comics";

  let comics = [];                 // [{name, url}]
  let indexByName = new Map();     // nameLower -> index
  let currentIndex = 0;

  // Tabs
  let currentTab = "all"; // "all" | "newest"
  const NEWEST_COUNT = 10;

  const statusEl = document.getElementById("status");
  const gridEl = document.getElementById("grid");
  const tabHintEl = document.getElementById("tabHint");

  function byNaturalName(a, b) {
    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" });
  }

  function setStatus(msg) {
    statusEl.classList.remove("hidden");
    statusEl.textContent = msg;
  }

  function showGrid() {
    statusEl.classList.add("hidden");
    gridEl.classList.remove("hidden");
  }

  function hideGrid() {
    gridEl.classList.add("hidden");
  }

  function loadFromCache() {
    try {
      const raw = localStorage.getItem(CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== "number") return null;
      if (Date.now() - parsed.ts > CACHE_TTL_MS) return null;
      return parsed.items;
    } catch {
      return null;
    }
  }

  function saveToCache(items) {
    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
    } catch {}
  }

  function urlsFromName(name) {
    return {
      cdn: `${CDN_BASE_URL}${encodeURIComponent(name)}`,
      raw: `${RAW_BASE_URL}${encodeURIComponent(name)}`
    };
  }

  function rebuildIndexMap() {
    indexByName = new Map();
    comics.forEach((c, i) => indexByName.set(c.name.toLowerCase(), i));
  }

  // ---- Tabs ----
  function setTab(tab) {
    currentTab = tab;
    updateTabUI();
    renderGrid();
  }

  function updateTabUI() {
    const allBtn = document.getElementById("tabAll");
    const newBtn = document.getElementById("tabNewest");

    const active = "bg-white text-black";
    const inactive = "bg-transparent text-white/80 hover:text-white hover:bg-white/10";

    allBtn.className = `retro text-[10px] sm:text-xs px-4 py-2 rounded-xl transition ${currentTab === "all" ? active : inactive}`;
    newBtn.className = `retro text-[10px] sm:text-xs px-4 py-2 rounded-xl transition ${currentTab === "newest" ? active : inactive}`;

    if (currentTab === "newest") {
      tabHintEl.textContent = `Showing newest ${Math.min(NEWEST_COUNT, comics.length)}`;
      tabHintEl.classList.remove("hidden");
    } else {
      tabHintEl.textContent = "";
      tabHintEl.classList.add("hidden");
    }
  }

  function visibleIndices() {
    if (currentTab !== "newest") return comics.map((_, i) => i);
    const n = Math.min(NEWEST_COUNT, comics.length);
    // "Newest" = highest numbered / last in sorted list; show newest first
    const start = Math.max(0, comics.length - n);
    const idxs = [];
    for (let i = comics.length - 1; i >= start; i--) idxs.push(i);
    return idxs;
  }

  // ---- Shareable URL helpers ----
  function baseDir() {
    const path = location.pathname;
    const marker = `/${SHARE_PREFIX}/`;
    if (path.includes(marker)) return path.split(marker)[0] + "/";
    if (path.endsWith("/")) return path;
    const lastSlash = path.lastIndexOf("/");
    return path.slice(0, lastSlash + 1);
  }

  function makeSharePath(filename) {
    return baseDir() + SHARE_PREFIX + "/" + encodeURIComponent(filename);
  }

  function makeShareUrl(filename) {
    return location.origin + makeSharePath(filename);
  }

  function makeHashShareUrl(filename) {
    return location.origin + baseDir() + "#/" + SHARE_PREFIX + "/" + encodeURIComponent(filename);
  }

  function parseFilenameFromUrl() {
    const path = location.pathname;
    const marker = `/${SHARE_PREFIX}/`;
    if (path.includes(marker)) {
      const part = path.split(marker)[1] || "";
      if (part) return decodeURIComponent(part.split("/")[0]);
    }

    const u = new URL(location.href);
    const img = u.searchParams.get("img");
    if (img) return img;

    const h = location.hash || "";
    const hm = h.match(new RegExp(`#\/${SHARE_PREFIX}\/([^?#]+)`));
    if (hm && hm[1]) return decodeURIComponent(hm[1]);

    return null;
  }

  function setUrlForCurrent(replace=false) {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;

    const newPath = makeSharePath(filename);

    try {
      if (replace) history.replaceState({ img: filename }, "", newPath);
      else history.pushState({ img: filename }, "", newPath);
    } catch {
      location.hash = `#/${SHARE_PREFIX}/${encodeURIComponent(filename)}`;
    }

    document.title = `EO Guides • ${filename}`;
  }

  function setUrlToHome(replace=false) {
    const home = baseDir();
    try {
      if (replace) history.replaceState({}, "", home);
      else history.pushState({}, "", home);
    } catch {
      location.hash = "";
    }
    document.title = "EO Guides";
  }

  function indexForFilename(filename) {
    if (!filename) return -1;
    return indexByName.get(filename.toLowerCase()) ?? -1;
  }

  // ---- Load comics list + render ----
  async function loadComics() {
    hideGrid();

    // Default tab selection (if someone opened a deep link, we still show tabs once loaded)
    updateTabUI();

    // 1) Instant render from cache (if available)
    const cached = loadFromCache();
    if (cached && cached.length) {
      comics = cached.sort(byNaturalName);
      rebuildIndexMap();
      renderGrid();
      showGrid();
      setStatus("Refreshing…");
    } else {
      setStatus("Loading comics…");
    }

    // 2) Try fresh file list from GitHub API
    try {
      const res = await fetch(API_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`GitHub API returned ${res.status}`);
      const data = await res.json();

      const fresh = data
        .filter(x => x.type === "file" && /\.(jpe?g|png|webp|gif)$/i.test(x.name))
        .map(x => ({ name: x.name, url: urlsFromName(x.name).cdn }))
        .sort(byNaturalName);

      if (!fresh.length) {
        setStatus("No images found in img/comics.");
        return;
      }

      const changed = JSON.stringify(fresh.map(x => x.name)) !== JSON.stringify(comics.map(x => x.name));
      comics = fresh;
      rebuildIndexMap();
      saveToCache(comics);

      updateTabUI();

      if (!cached || changed) {
        renderGrid();
        showGrid();
      } else {
        statusEl.classList.add("hidden");
      }

      maybeOpenFromUrl();
      return;

    } catch (err) {
      console.warn("GitHub API listing failed; falling back.", err);
      if (comics.length) {
        statusEl.classList.add("hidden");
        maybeOpenFromUrl();
        return;
      }
    }

    // 3) Fallback: probe sequential files (still avoids showing missing ones)
    setStatus("Scanning images…");

    const max = 500;
    const found = [];
    const concurrency = 12;

    async function exists(url) {
      try {
        let r = await fetch(url, { method: "HEAD" });
        if (r.ok) return true;
        r = await fetch(url, { method: "GET" });
        return r.ok;
      } catch {
        return false;
      }
    }

    const tasks = [];
    for (let i = 1; i <= max; i++) {
      const num = String(i).padStart(3, "0");
      const name = `${num}.jpg`;
      tasks.push({ name, url: urlsFromName(name).cdn });
    }

    for (let i = 0; i < tasks.length; i += concurrency) {
      const batch = tasks.slice(i, i + concurrency);
      const results = await Promise.all(batch.map(t => exists(t.url)));
      results.forEach((ok, idx) => { if (ok) found.push(batch[idx]); });
      setStatus(`Scanning images… ${Math.min(i + concurrency, max)} / ${max}`);
    }

    comics = found.sort(byNaturalName);
    rebuildIndexMap();
    updateTabUI();

    if (!comics.length) {
      setStatus("Couldn't find any images to load.");
      return;
    }

    saveToCache(comics);
    renderGrid();
    showGrid();
    maybeOpenFromUrl();
  }

  function renderGrid() {
    gridEl.innerHTML = "";

    // Only load images when they get close to the viewport.
    // This is stronger than loading="lazy" alone and helps a lot on mobile.
    const BLANK = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

    // Reset old observer (tab switches re-render the grid)
    if (window.__eoImgObserver) {
      window.__eoImgObserver.disconnect();
      window.__eoImgObserver = null;
    }

    const supportsIO = ("IntersectionObserver" in window);

    if (supportsIO) {
      window.__eoImgObserver = new IntersectionObserver((entries, obs) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;

          const img = entry.target;
          const realSrc = img.dataset.src;
          if (realSrc) {
            img.src = realSrc;
            // keep dataset until load succeeds, so we can ignore the BLANK onload
          }
          obs.unobserve(img);
        }
      }, {
        root: null,
        // start loading slightly before the card enters view
        rootMargin: "500px 0px",
        threshold: 0.01
      });
    }

    const idxs = visibleIndices();
    idxs.forEach((globalIdx) => {
      const comic = comics[globalIdx];

      const link = document.createElement("a");
      link.href = makeSharePath(comic.name);
      link.className =
        "relative block cursor-pointer bg-neutral-900 rounded-xl overflow-hidden hover:scale-105 transition focus:outline-none focus:ring-2 focus:ring-white/30";

      link.addEventListener("click", (e) => {
        e.preventDefault();
        openReader(globalIdx, false);
      });

      const ph = document.createElement("div");
      ph.className = "absolute inset-0 shimmer";
      link.appendChild(ph);

      const img = document.createElement("img");
      img.alt = comic.name;
      img.className = "relative w-full aspect-[3/4] object-cover";
      img.loading = "lazy";
      img.decoding = "async";
      img.fetchPriority = "low";

      // Start with a tiny blank image so nothing is fetched until we decide.
      img.src = BLANK;
      img.dataset.src = comic.url;

      img.onload = () => {
        // Ignore the blank image load; only remove shimmer once real image is in.
        if (img.src === BLANK) return;
        ph.remove();
        img.removeAttribute("data-src");
      };

      img.onerror = () => {
        // If the CDN fails, fall back to raw URL.
        // If raw fails too, remove the card.
        if (img.src === BLANK) return;

        const fallback = urlsFromName(comic.name).raw;
        if (img.src !== fallback) img.src = fallback;
        else link.remove();
      };

      link.appendChild(img);
      gridEl.appendChild(link);

      // Observe for in-view loading (or just load immediately if IO not supported)
      if (supportsIO && window.__eoImgObserver) {
        window.__eoImgObserver.observe(img);
      } else {
        img.src = comic.url;
      }
    });
  }

  // ---- Reader modal ----
  function openReader(idx, push=true) {
    if (!comics.length) return;
    currentIndex = Math.max(0, Math.min(idx, comics.length - 1));
    updateReader();
    document.getElementById("reader").classList.remove("hidden");
    document.body.classList.add("no-scroll");
    document.getElementById("readerScroll").scrollTop = 0;

    document.getElementById("shareBtn").classList.toggle("hidden", !("share" in navigator));

    if (push) setUrlForCurrent(false);
    else setUrlForCurrent(true);
  }

  function closeReader() {
    document.getElementById("reader").classList.add("hidden");
    document.body.classList.remove("no-scroll");
    setUrlToHome(false);
  }

  // Preload next/prev
  const preloadCache = new Map();
  function preload(url) {
    if (!url || preloadCache.has(url)) return;
    const im = new Image();
    im.decoding = "async";
    im.src = url;
    preloadCache.set(url, im);
    if (preloadCache.size > 12) {
      const firstKey = preloadCache.keys().next().value;
      preloadCache.delete(firstKey);
    }
  }

  function preloadAround() {
    const prev = comics[currentIndex - 1]?.url;
    const next = comics[currentIndex + 1]?.url;
    preload(prev); preload(next);
  }

  function updateReader() {
    const comic = comics[currentIndex];
    const img = document.getElementById("readerImage");
    const ph  = document.getElementById("readerPlaceholder");

    img.classList.add("hidden");
    ph.classList.remove("hidden");

    img.onerror = () => {
      const fallback = urlsFromName(comic.name).raw;
      if (img.src !== fallback) img.src = fallback;
    };

    img.onload = () => {
      ph.classList.add("hidden");
      img.classList.remove("hidden");
    };

    img.src = comic.url;

    document.getElementById("pageCounter").innerText =
      `${currentIndex + 1} / ${comics.length} • ${comic.name}`;

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const atStart = currentIndex === 0;
    const atEnd = currentIndex === comics.length - 1;

    prevBtn.classList.toggle("opacity-30", atStart);
    prevBtn.classList.toggle("pointer-events-none", atStart);

    nextBtn.classList.toggle("opacity-30", atEnd);
    nextBtn.classList.toggle("pointer-events-none", atEnd);

    preloadAround();
    setUrlForCurrent(true);
  }

  function nextPage() {
    if (currentIndex < comics.length - 1) {
      currentIndex++;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  function prevPage() {
    if (currentIndex > 0) {
      currentIndex--;
      updateReader();
      document.getElementById("readerScroll").scrollTop = 0;
    }
  }

  // ---- Sharing ----
  function currentShareUrl() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return location.href;
    return makeShareUrl(filename);
  }

  async function copyShareLink() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;

    const url = currentShareUrl();
    const fallback = makeHashShareUrl(filename);

    try {
      await navigator.clipboard.writeText(url);
      flashCopy("Copied!");
    } catch {
      try {
        const ta = document.createElement("textarea");
        ta.value = url;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        flashCopy("Copied!");
      } catch {
        prompt("Copy this link:", fallback);
      }
    }
  }

  function flashCopy(text) {
    const btn = document.getElementById("copyLinkBtn");
    const old = btn.textContent;
    btn.textContent = text;
    setTimeout(() => btn.textContent = old, 900);
  }

  async function nativeShare() {
    const filename = comics[currentIndex]?.name;
    if (!filename) return;
    const url = currentShareUrl();

    try {
      await navigator.share({ title: `EO Guides • ${filename}`, url });
    } catch {}
  }

  // ---- Deep link open ----
  function maybeOpenFromUrl() {
    const filename = parseFilenameFromUrl();
    if (!filename) return;

    const idx = indexForFilename(filename);
    if (idx >= 0) {
      openReader(idx, false);
    } else {
      setUrlToHome(true);
    }
  }

  // Back/forward should update modal state
  window.addEventListener("popstate", () => {
    const filename = parseFilenameFromUrl();
    if (!filename) {
      if (!document.getElementById("reader").classList.contains("hidden")) {
        document.getElementById("reader").classList.add("hidden");
        document.body.classList.remove("no-scroll");
        document.title = "EO Guides";
      }
      return;
    }

    const idx = indexForFilename(filename);
    if (idx >= 0) {
      document.getElementById("reader").classList.remove("hidden");
      document.body.classList.add("no-scroll");
      currentIndex = idx;
      updateReader();
    }
  });

  // Keyboard controls
  document.addEventListener("keydown", e => {
    const readerOpen = !document.getElementById("reader").classList.contains("hidden");
    if (!readerOpen) return;

    if (e.key === "ArrowRight") nextPage();
    if (e.key === "ArrowLeft") prevPage();
    if (e.key === "Escape") closeReader();
  });

  // Swipe support
  let startX = 0;
  const readerImage = document.getElementById("readerImage");
  readerImage.addEventListener("touchstart", e => { startX = e.touches[0].clientX; }, { passive: true });
  readerImage.addEventListener("touchend", e => {
    const diff = e.changedTouches[0].clientX - startX;
    if (diff > 60) prevPage();
    if (diff < -60) nextPage();
  }, { passive: true });

  // DISCLAIMER
  function openDisclaimer() {
    document.getElementById("disclaimer").classList.remove("hidden");
    document.body.classList.add("no-scroll");
  }

  function acceptDisclaimer() {
    localStorage.setItem("discAccepted", "true");
    document.getElementById("disclaimer").classList.add("hidden");
    document.body.classList.remove("no-scroll");
  }

  if (!localStorage.getItem("discAccepted")) {
    openDisclaimer();
  }

  // Kick off
  updateTabUI();
  loadComics();
</script>

</body>
</html>
